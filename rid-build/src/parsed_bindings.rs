use crate::{
    function_header::FunctionHeader,
    function_header_parser::parse_function_header,
};

const TYPEDEF_STRUCT: &str = "typedef struct ";
const TYPEDEF_STRUCT_LEN: usize = TYPEDEF_STRUCT.len();

const TYPEDEF_ENUM: &str = "typedef enum ";
const TYPEDEF_ENUM_LEN: usize = TYPEDEF_ENUM.len();

pub struct ParsedBindings {
    pub dart_code: String,
    pub swift_code: String,
    pub structs: Vec<String>,
    pub enums: Vec<String>,
}

enum Section {
    Dart,
}

impl ParsedBindings {
    /// Code sections derived from binding.h generated by cbindgen with functions and structs
    /// expanded via rid-macro.
    pub fn new(binding: &str) -> Self {
        use Section::*;

        let mut dart_sections: Vec<Vec<String>> = vec![];

        let mut inside_section: Option<Section> = None;
        let mut current_section: Vec<String> = vec![];

        let mut structs: Vec<String> = vec![];
        let mut enums: Vec<String> = vec![];

        let mut function_headers: Vec<FunctionHeader> = vec![];

        for line in binding.lines() {
            match &inside_section {
                Some(section) => {
                    let trimmed_line = line.trim();
                    if trimmed_line.len() < 2 {
                        continue;
                    }
                    if trimmed_line.starts_with("* ```") {
                        // Done with current code section
                        match section {
                            Dart => dart_sections.push(current_section),
                        }
                        current_section = vec![];
                        inside_section = None;
                        continue;
                    }
                    // Inside code section
                    let without_comment = &trimmed_line[2..];
                    current_section.push(without_comment.to_string());
                }
                None => {
                    let trimmed = line.trim_start();
                    if trimmed.starts_with("* ```dart") {
                        // Starting new dart section
                        inside_section = Some(Dart);
                    } else if trimmed.starts_with(TYPEDEF_STRUCT) {
                        // Outside any section, collecting structs via type defs
                        let (struct_name, _) = trimmed[TYPEDEF_STRUCT_LEN..]
                            .split_once(" ")
                            .expect(&format!(
                                "Invalid struct definition {}",
                                &trimmed
                            ));
                        structs.push(struct_name.to_string());
                    } else if trimmed.starts_with(TYPEDEF_ENUM) {
                        let (enum_name, _) = trimmed[TYPEDEF_ENUM_LEN..]
                            .split_once(" ")
                            .expect(&format!(
                                "Invalid enum definition {}",
                                &trimmed
                            ));
                        enums.push(enum_name.to_string());
                    } else if let Some(header) = parse_function_header(trimmed)
                    {
                        function_headers.push(header);
                    }
                    continue;
                }
            }
        }

        let dart_code = join_sections(dart_sections);
        let swift_calls: Vec<String> = function_headers
            .into_iter()
            .map(|x| x.render_swift_call())
            .collect();

        let swift_code = if swift_calls.is_empty() {
            "".to_string()
        } else {
            format!(
                r###"func dummyCallsToPreventTreeShaking() {{
    {calls};
}}"###,
                calls = swift_calls.join(";\n    ")
            )
        };

        structs.sort();
        structs.dedup();

        Self {
            dart_code,
            swift_code,
            structs,
            enums,
        }
    }
}

fn join_sections(sections: Vec<Vec<String>>) -> String {
    sections
        .into_iter()
        .map(|section| {
            let last_line = section.len() - 1;
            section.into_iter().enumerate().fold(
                "".to_string(),
                |acc, (idx, sect)| {
                    if idx == 0 || idx == last_line {
                        let new_line = if idx == 0 { "" } else { "\n" };
                        format!(
                            "{acc}{new_line}{sect}",
                            acc = acc,
                            new_line = new_line,
                            sect = sect
                        )
                    } else {
                        format!("{acc}\n  {ext}", acc = acc, ext = sect)
                    }
                },
            )
        })
        .fold("".to_string(), |acc, ref section| {
            let new_line = if acc == "" { "" } else { "\n\n" };
            format!(
                "{acc}{new_line}{section}",
                acc = acc,
                new_line = new_line,
                section = section
            )
        })
}
