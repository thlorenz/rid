use std::collections::{HashMap, HashSet};

use crate::{
    function_header::FunctionHeader,
    function_header_parser::parse_function_header,
};

const TYPEDEF_STRUCT: &str = "typedef struct ";
const TYPEDEF_STRUCT_LEN: usize = TYPEDEF_STRUCT.len();

const TYPEDEF_ENUM: &str = "typedef enum ";
const TYPEDEF_ENUM_LEN: usize = TYPEDEF_ENUM.len();

pub struct ParsedBindings {
    /// Dart code extracted from the dart code blocks inside the binding
    pub dart_code: String,

    /// Swift generated from the binding's function headers
    pub swift_code: String,

    /// Structs found in the bindings file
    pub structs: Vec<String>,

    /// Enums found inside the bindings file.
    ///
    /// NOTE: that at this point **enums aren't re-exported** in the generated code as we generate
    /// Dart representations of the same type.
    /// Once we prefix the native enums with 'Raw' like we do for structs we can reexport those
    /// again.
    /// They'd be merely of use to devs using the raw API as they aren't referenced anywhere in the
    /// generated code as variants are represented as `int`s instead. A simple search/replace inside the
    /// bindgen.h should suffice.
    pub enums: Vec<String>,

    /// The modified binding content
    /// At this point this is necessary in order to prepare type aliases for dart ffigen
    pub updated_binding: String,
}

enum Section {
    Dart,
}

impl ParsedBindings {
    /// Code sections derived from binding.h generated by cbindgen with functions and structs
    /// expanded via rid-macro.
    pub fn new(binding: &str) -> Self {
        use Section::*;

        let mut dart_sections: Vec<Vec<String>> = vec![];

        let mut inside_section: Option<Section> = None;
        let mut current_section: Vec<String> = vec![];

        let mut structs: Vec<(String, usize)> = vec![];
        let mut struct_aliases: HashMap<String, (String, usize)> =
            HashMap::new();
        let mut enums: Vec<String> = vec![];

        let mut function_headers: Vec<FunctionHeader> = vec![];

        for (lineno, line) in binding.lines().enumerate() {
            match &inside_section {
                Some(section) => {
                    let trimmed_line = line.trim();
                    if trimmed_line.len() < 2 {
                        continue;
                    }
                    if trimmed_line.starts_with("* ```") {
                        // Done with current code section
                        match section {
                            Dart => dart_sections.push(current_section),
                        }
                        current_section = vec![];
                        inside_section = None;
                        continue;
                    }
                    // Inside code section
                    let without_comment = &trimmed_line[2..];
                    current_section.push(without_comment.to_string());
                }
                None => {
                    let trimmed = line.trim();
                    if trimmed.starts_with("* ```dart") {
                        // Starting new dart section
                        inside_section = Some(Dart);
                    } else if trimmed.starts_with(TYPEDEF_STRUCT)
                        && trimmed.ends_with(";")
                    {
                        let trimmed = trimmed.trim_end_matches(";");
                        // Outside any section, collecting structs via type defs
                        let (struct_name, alias_name) = trimmed
                            [TYPEDEF_STRUCT_LEN..]
                            .split_once(" ")
                            .expect(&format!(
                                "Invalid struct definition {}",
                                &trimmed
                            ));
                        if struct_name == alias_name {
                            // typedef struct Todo Todo;
                            structs.push((struct_name.to_string(), lineno));
                        } else {
                            // typedef struct Todo RawTodo;
                            struct_aliases.insert(
                                struct_name.to_string(),
                                (alias_name.to_string(), lineno),
                            );
                        };
                    } else if trimmed.starts_with(TYPEDEF_ENUM) {
                        let (enum_name, _) = trimmed[TYPEDEF_ENUM_LEN..]
                            .split_once(" ")
                            .expect(&format!(
                                "Invalid enum definition {}",
                                &trimmed
                            ));
                        enums.push(enum_name.to_string());
                    } else if let Some(header) = parse_function_header(trimmed)
                    {
                        function_headers.push(header);
                    }
                    continue;
                }
            }
        }

        let updated_binding =
            replace_struct_aliases(binding, &structs, &struct_aliases);

        let dart_code = join_sections(dart_sections);
        let swift_calls: Vec<String> = function_headers
            .into_iter()
            .map(|x| x.render_swift_call())
            .collect();

        let swift_code = if swift_calls.is_empty() {
            "".to_string()
        } else {
            format!(
                r###"func dummyCallsToPreventTreeShaking() {{
    {calls};
}}"###,
                calls = swift_calls.join(";\n    ")
            )
        };

        let structs: Vec<String> = {
            let mut structs: Vec<String> =
                structs_to_include(&structs, &struct_aliases);
            structs.sort();
            structs.dedup();
            structs
        };

        Self {
            dart_code,
            swift_code,
            structs,
            enums,
            updated_binding,
        }
    }
}

fn join_sections(sections: Vec<Vec<String>>) -> String {
    sections
        .into_iter()
        .map(|section| {
            let last_line = section.len() - 1;
            section.into_iter().enumerate().fold(
                "".to_string(),
                |acc, (idx, sect)| {
                    if idx == 0 || idx == last_line {
                        let new_line = if idx == 0 { "" } else { "\n" };
                        format!(
                            "{acc}{new_line}{sect}",
                            acc = acc,
                            new_line = new_line,
                            sect = sect
                        )
                    } else {
                        format!("{acc}\n  {ext}", acc = acc, ext = sect)
                    }
                },
            )
        })
        .fold("".to_string(), |acc, ref section| {
            let new_line = if acc == "" { "" } else { "\n\n" };
            format!(
                "{acc}{new_line}{section}",
                acc = acc,
                new_line = new_line,
                section = section
            )
        })
}

// Dart ffigen doesn't handle type aliases very well, so we just have to remove the original struct
// declaration and replace it with the one that it was aliased to. For example:
// ```
// typedef struct Todo Todo;
// typedef struct RawTodo Todo;
// ```
//
// becomes:
// ```
// typedef struct RawTodo RawTodo;
// ```
fn replace_struct_aliases(
    binding: &str,
    structs: &[(String, usize)],
    struct_aliases: &HashMap<String, (String, usize)>,
) -> String {
    let lines_to_remove: HashSet<usize> = structs
        .iter()
        .filter_map(|(name, lineno)| {
            if struct_aliases.contains_key(name) {
                Some(*lineno)
            } else {
                None
            }
        })
        .collect();

    let replace: HashMap<usize, String> = struct_aliases
        .values()
        .map(|(struct_name, lineno)| {
            let line = format!(
                "typedef struct {struct_name} {struct_name};",
                struct_name = struct_name
            );
            (*lineno, line)
        })
        .collect();

    binding
        .lines()
        .enumerate()
        .filter_map(|(lineno, line)| {
            if lines_to_remove.contains(&lineno) {
                None
            } else {
                match replace.get(&lineno) {
                    Some(replacement) => Some(replacement.to_string()),
                    None => Some(line.to_string()),
                }
            }
        })
        .collect::<Vec<String>>()
        .join("\n")
}

fn structs_to_include(
    structs: &[(String, usize)],
    struct_aliases: &HashMap<String, (String, usize)>,
) -> Vec<String> {
    structs
        .iter()
        .map(|(x, _)| match struct_aliases.get(x) {
            Some((alias, _)) => alias.to_string(),
            None => x.to_string(),
        })
        .collect()
}
