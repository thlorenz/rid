use std::{fmt::Display, fs, iter::FromIterator, path::Path};

use anyhow::Result;

use bindings_generator::BindingsGenerator;
use dart_generator::DartGenerator;

mod bindings_generator;
mod build_target;
mod constants;
mod dart_generator;
mod ffigen;
mod function_header;
mod function_header_parser;
mod log;
mod parsed_bindings;
mod project;
mod swift_injector;

pub use build_target::BuildTarget;
use ffigen::{run_ffigen, HostProps};
pub use project::{FlutterConfig, FlutterPlatform, Project};

use crate::{parsed_bindings::ParsedBindings, swift_injector::SwiftInjector};

static ISOLATE_BINDING: &str = include_str!("../dart/_isolate_binding.dart");
static MESSAGE_CHANNEL: &str = include_str!("../dart/_message_channel.dart");
static REPLY_CHANNEL: &str = include_str!("../dart/_reply_channel.dart");

pub struct BuildConfig<'a> {
    pub project_root: &'a str,
    pub workspace_root: Option<&'a str>,
    pub lib_name: &'a str,
    pub crate_name: &'a str,
    pub project: Project,
    pub target: BuildTarget,
}

/// Result of generating C header file via cbindgen as well as the Dart derived from it.
/// The header file is written as a side effect. For Flutter it is placed inside the `ios/Classes`
/// folder where it is needed, for Dart it is placed alongside the generated dart for now.
/// The generated Dart and the path to where it should be placed is included as well.
#[derive(Debug)]
pub struct BuildResult {
    /// Content of Dart generated and to be included by the Dart or Flutter app.
    generated_dart: String,

    /// Path to Dart that binds to Rust implementation Dart Isolate provided by Rid.
    isolate_binding_dart_path: String,

    /// Path to Dart that provides Message through which Rid communicates messages to Dart.
    message_channel_dart_path: String,

    /// Path to Dart that provides ResponseChannel through which user's Rust code posts messages to Dart.
    reply_channel_dart_path: String,

    /// Path at which the Dart/Flutter app expects the generated Dart code to be and from which the
    /// generated code imports the darg ffigen generated bindings.
    /// This file still needs to be written.
    generated_dart_path: String,

    /// Path at which the C headers file was ALREADY written. This may be ignored for Dart apps,
    /// but should be located in the correct location for Flutter apps.
    generated_bindings_h_path: String,

    /// Swift plugin files that were modified in ordert to prevent Rust functions from being
    /// removed via tree shaking.
    swift_plugin_files: Vec<String>,

    /// Result of parsing `bindings.h` C-header file.
    parsed_bindings: ParsedBindings,
}

impl Display for BuildResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "
Rid Build Result
================
Path to generated bindings:    {generated_bindings_h_path}
Path to Dart exposing Rid FFI: {generated_dart_path}
Path to Dart Isolate Binding:  {isolate_binding_dart_path}
Path to Dart Response Channel: {reply_channel_dart_path}
Paths to modified Swift:       [{swift_plugin_files}]
",
            generated_bindings_h_path = self.generated_bindings_h_path,
            generated_dart_path = self.generated_dart_path,
            isolate_binding_dart_path = self.isolate_binding_dart_path,
            reply_channel_dart_path = self.reply_channel_dart_path,
            swift_plugin_files = self.swift_plugin_files.join(", "),
        )
    }
}

fn generate(
    BuildConfig {
        project_root,
        workspace_root,
        lib_name,
        crate_name,
        project,
        target,
    }: &BuildConfig,
) -> Result<BuildResult> {
    let expand_args = target.cargo_expand_args();
    let bindings_generator = BindingsGenerator {
        crate_name,
        crate_dir: project_root,
        cargo: "cargo",
        expand_args,
    };
    let target_crate_root = Path::new(workspace_root.unwrap_or(project_root));
    let project_root = Path::new(project_root);
    log::info!("Generating bindings");

    let bindings_h = bindings_generator.generate()?;
    let bindings_h_paths = project.paths_to_generated_c_bindings(project_root);

    // TODO: cbindgen unwraps all over the place here, so we should ensure that we can
    // access the file we're writing to
    // NOTE: as a side effect we write the binding.h file here already, it goes unused for Dart,
    // but is essential for Flutter ios apps.
    for bindings_h_path in &bindings_h_paths {
        bindings_h.write_to_file(&bindings_h_path);
    }
    let bindings_h_path = &bindings_h_paths[0];
    let bindings_h_content = fs::read_to_string(&bindings_h_path)?;

    // NOTE: this is generated by dart ffigen step which we don't corrently control
    let ffigen_generated_path = project.path_to_generated_ffigen(project_root);
    let rid_generated_api_path = project.path_to_rid_dart_api(project_root);
    let isolate_binding_dart_path =
        project.path_to_isolate_binding_dart(project_root);
    let message_channel_dart_path =
        project.path_to_message_channel_dart(project_root);
    let reply_channel_dart_path =
        project.path_to_reply_channel_dart(project_root);

    // TODO: determine this as relative path from  'generated_dart_path' -> 'ffigen_generated_path'
    let ffigen_binding = &format!(
        "{}",
        ffigen_generated_path.file_name().unwrap().to_string_lossy()
    );
    let message_channel = &format!(
        "{}",
        message_channel_dart_path
            .file_name()
            .unwrap()
            .to_string_lossy()
    );
    let reply_channel = &format!(
        "{}",
        reply_channel_dart_path
            .file_name()
            .unwrap()
            .to_string_lossy()
    );
    let path_to_target =
        &format!("{}", project.path_to_target(target_crate_root).display());

    // Extract Dart and Swift code from bindings.h
    let parsed_bindings = ParsedBindings::new(&bindings_h_content);
    for binding_path in &bindings_h_paths {
        fs::write(binding_path, &parsed_bindings.updated_binding)?;
    }

    // Generate Dart glue code and add to code extracted from bindings.h
    log::info!("Generating Dart glue code");
    let dart_generator = DartGenerator {
        lib_name,
        target,
        ffigen_binding,
        message_channel,
        reply_channel,
        path_to_target,
        code_sections: &parsed_bindings,
        project: &project,
        needs_store_stub: !parsed_bindings.has_store_lock,
        needs_reply_channel_stub: !parsed_bindings.has_reply_channel,
    };
    let generated_dart = dart_generator.generate();

    // Inject swift code to prevent tree shaking
    log::info!("Injecting Swift code into plugin");
    let swift_injector = SwiftInjector { project: &project };
    let swift_plugin_files = swift_injector
        .inject(&project_root, &parsed_bindings.swift_code)?
        .into_iter()
        .map(|x| format!("{}", x.display()))
        .collect();

    Ok(BuildResult {
        generated_dart,
        generated_dart_path: format!("{}", rid_generated_api_path.display()),
        isolate_binding_dart_path: format!(
            "{}",
            isolate_binding_dart_path.display()
        ),
        message_channel_dart_path: format!(
            "{}",
            message_channel_dart_path.display()
        ),
        reply_channel_dart_path: format!(
            "{}",
            reply_channel_dart_path.display()
        ),
        generated_bindings_h_path: format!("{}", bindings_h_path.display()),
        swift_plugin_files,
        parsed_bindings,
    })
}

pub fn build(build_config: &BuildConfig) -> Result<BuildResult> {
    log::init();

    let generate_result = generate(build_config)?;
    let BuildResult {
        generated_dart,
        generated_dart_path,
        isolate_binding_dart_path,
        message_channel_dart_path,
        reply_channel_dart_path,
        parsed_bindings,
        ..
    } = &generate_result;

    // NOTE: the directory to hold the file is recursively created if it doesn't exist yet
    fs::write(generated_dart_path, generated_dart)?;
    fs::write(isolate_binding_dart_path, ISOLATE_BINDING)?;
    fs::write(message_channel_dart_path, MESSAGE_CHANNEL)?;
    fs::write(reply_channel_dart_path, REPLY_CHANNEL)?;

    let host_props = HostProps::new();
    let project_root: &Path = Path::new(build_config.project_root);
    let structs_to_prefix_raw: Vec<String> =
        Vec::from_iter(parsed_bindings.raw_structs());

    run_ffigen(
        &build_config.project,
        &host_props,
        project_root,
        &structs_to_prefix_raw,
    )?;

    Ok(generate_result)
}

// TODO: disabled due to getting stuck
#[cfg(test_disabled)]
mod tests {
    use super::*;

    #[test]
    fn generate_test() {
        let build_config = BuildConfig {
            project_root: "fixtures/foo-bar-baz",
            workspace_root: None,
            project: Project::Dart,
            lib_name: "libfoo_bar_baz",
            crate_name: "foo_bar_baz",
            target: BuildTarget::Debug,
        };
        let result = generate(&build_config);
        match result {
            Err(err) => assert!(false, "generate should not error {}", err),
            Ok(result) => println!("{:#?}", result),
        };
    }
}
