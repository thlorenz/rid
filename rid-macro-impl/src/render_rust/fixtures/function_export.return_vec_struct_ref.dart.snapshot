 extension Rid_Vec_ExtOnPointerRidVec_Pointer_RawMyStruct on ffigen_bind.RidVec_Pointer_RawMyStruct {
   dart_ffi.Pointer<ffigen_bind.RawMyStruct> operator [](int idx) {
     final len = this.length;
     if (!(0 <= idx && idx < len)) {
       throw AssertionError("Out of range access on List<dart_ffi.Pointer<ffigen_bind.RawMyStruct>>[$idx] of length $len");
     }
     return rid_ffi.rid_get_item_Pointer_RawMyStruct(this, idx);
   }

   void dispose() {
     rid_ffi.rid_free_vec_Pointer_RawMyStruct(this);
   }

   Rid_RidVec_Pointer_RawMyStruct_Iterable iter() => Rid_RidVec_Pointer_RawMyStruct_Iterable(this);
 }

 class Rid_RidVec_Pointer_RawMyStruct_Iterator implements Iterator<dart_ffi.Pointer<ffigen_bind.RawMyStruct>> {
   int _currentIdx = -1;
   final ffigen_bind.RidVec_Pointer_RawMyStruct _vec;
   final int _limit;

   Rid_RidVec_Pointer_RawMyStruct_Iterator(this._vec) : _limit = _vec.length - 1;

   dart_ffi.Pointer<ffigen_bind.RawMyStruct> get current => _vec[_currentIdx];

   bool moveNext() {
     if (_currentIdx >= _limit) return false;
     _currentIdx++;
     return true;
   }
 }

 class Rid_RidVec_Pointer_RawMyStruct_Iterable with
     dart_collection.IterableMixin<dart_ffi.Pointer<ffigen_bind.RawMyStruct>> {
   final ffigen_bind.RidVec_Pointer_RawMyStruct _vec;
   Rid_RidVec_Pointer_RawMyStruct_Iterable(this._vec);

   Iterator<dart_ffi.Pointer<ffigen_bind.RawMyStruct>> get iterator =>
     Rid_RidVec_Pointer_RawMyStruct_Iterator(this._vec);
 }
